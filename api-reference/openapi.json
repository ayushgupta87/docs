{
  "openapi": "3.0.3",
  "info": {
    "title": "Hookpulse API",
    "description": "Complete API documentation for Hookpulse. Build powerful integrations with our RESTful API.",
    "version": "1.0.0",
    "contact": {
      "name": "Hookpulse Support",
      "email": "care@hookpulse.io",
      "url": "https://hookpulse.io"
    }
  },
  "servers": [
    {
      "url": "https://api.hookpulse.io",
      "description": "Production server"
    }
  ],
  "security": [
    {
      "apiKeyAuth": [],
      "brandUuidAuth": []
    }
  ],
  "paths": {
    "/resources": {
      "get": {
        "description": "Returns all resources from your Hookpulse account",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return (default: 20, max: 100)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 100,
              "default": 20
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of results to skip for pagination",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                  "type": "array",
                  "items": {
                        "$ref": "#/components/schemas/Resource"
                      }
                    },
                    "pagination": {
                      "$ref": "#/components/schemas/Pagination"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Creates a new resource in your Hookpulse account",
        "requestBody": {
          "description": "Resource data to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateResource"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Resource created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "$ref": "#/components/schemas/Resource"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/resources/{id}": {
      "delete": {
        "description": "Deletes a resource by ID",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Unique identifier of the resource to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Resource deleted successfully",
            "content": {}
          },
          "400": {
            "description": "unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_domain/": {
      "post": {
        "description": "Add a new domain to your HookPulse account with rate limiting and concurrency control settings",
        "requestBody": {
          "description": "Domain configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddDomainRequest"
        }
      }
    }
  },
        "responses": {
          "200": {
            "description": "Domain added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddDomainResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_domain_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of domains from your HookPulse account",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "Page number to retrieve (starts from 1)",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDomainPaginatedResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_domain_uuid/": {
      "post": {
        "description": "Retrieve the UUID for a specific domain by providing the domain name and protocol type",
        "requestBody": {
          "description": "Domain lookup request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDomainUuidRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDomainUuidResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/webhook": {
      "post": {
        "description": "Webhook endpoint for receiving real-time events from Hookpulse",
        "requestBody": {
          "description": "Webhook event payload",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookEvent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook received successfully"
          }
        }
      }
    },
    "/v1/api/add_webhook_template/": {
      "post": {
        "description": "Create a new webhook template with configurable retry logic, timeout settings, and template variable support",
        "requestBody": {
          "description": "Webhook template configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddWebhookTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWebhookTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_webhook_template_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of all webhook templates in your HookPulse account",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "Page number to retrieve (starts from 1)",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWebhookTemplatePaginatedResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/single_webhook_template_detail/": {
      "post": {
        "description": "Retrieve detailed information about a specific webhook template by its UUID",
        "requestBody": {
          "description": "Webhook template lookup request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWebhookTemplateUuidRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWebhookTemplateUuidResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_webhook_template_uuid/": {
      "post": {
        "description": "Retrieve the UUID of a webhook template by providing its name",
        "requestBody": {
          "description": "Webhook template lookup by name",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWebhookTemplateUuidByNameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWebhookTemplateUuidByNameResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWebhookTemplateUuidByNameErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/delete_webhook_template/": {
      "delete": {
        "description": "Delete a webhook template from your HookPulse account",
        "requestBody": {
          "description": "Webhook template deletion request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteWebhookTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook template deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWebhookTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_workflow_template/": {
      "post": {
        "description": "Create a new workflow template with FIFO or concurrent execution mode",
        "requestBody": {
          "description": "Workflow template configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddWorkflowTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflow template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWorkflowTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request (e.g., workflow with same name already exists)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWorkflowTemplateErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_workflow_template_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of all workflow templates in your HookPulse account",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "Page number to retrieve (starts from 1)",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowTemplatePaginatedResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_workflow_template_uuid/": {
      "post": {
        "description": "Retrieve the UUID of a workflow template by providing its name",
        "requestBody": {
          "description": "Workflow template name",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWorkflowTemplateUuidRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowTemplateUuidResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or workflow not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_workflow_step/": {
      "post": {
        "description": "Add a webhook step to an existing workflow template",
        "requestBody": {
          "description": "Workflow step configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddWorkflowStepRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflow step added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWorkflowStepResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/single_workflow_template_detail/": {
      "post": {
        "description": "Retrieve detailed information about a specific workflow template by its UUID, including all workflow steps",
        "requestBody": {
          "description": "Workflow template UUID",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWorkflowTemplateDetailRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowTemplateDetailResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or workflow not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_system_secret/": {
      "post": {
        "description": "Add a new secret to the System Secret Vault for use in webhook templates",
        "requestBody": {
          "description": "Secret configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddSystemSecretRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Secret added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddSystemSecretResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request (e.g., key already exists)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddSystemSecretErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_secrets_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of all system secrets stored in your vault",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "Page number to retrieve (starts from 1)",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSecretsPaginatedResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/update_secret_value/": {
      "post": {
        "description": "Update the value of an existing system secret in the vault",
        "requestBody": {
          "description": "Secret update configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSecretValueRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Secret value updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateSecretValueResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_value_of_secret/": {
      "post": {
        "description": "Retrieve the value and details of a specific system secret by its UUID",
        "requestBody": {
          "description": "Secret lookup request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetValueOfSecretRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetValueOfSecretResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/delete_secret/": {
      "delete": {
        "description": "Delete a system secret from the vault",
        "requestBody": {
          "description": "Secret deletion request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSecretRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Secret deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSecretResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or deletion failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSecretErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/timezone_options/": {
      "get": {
        "description": "Retrieve a complete list of all available IANA timezones supported by HookPulse",
        "responses": {
          "200": {
            "description": "Successful response with list of timezones",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TimezoneOptionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_interval_schedule/": {
      "post": {
        "description": "Create a new interval-based schedule that executes a webhook or workflow at regular intervals",
        "requestBody": {
          "description": "Interval schedule configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddIntervalScheduleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schedule created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_cron_schedule/": {
      "post": {
        "description": "Create a new cron-based schedule that executes a webhook or workflow using standard cron expressions",
        "requestBody": {
          "description": "Cron schedule configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddCronScheduleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schedule created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_clocked_schedule/": {
      "post": {
        "description": "Create a one-time scheduled task that executes a webhook or workflow at a specific date and time",
        "requestBody": {
          "description": "Clocked schedule configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddClockedScheduleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schedule created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_schedule_rule/": {
      "post": {
        "description": "Add a rule to an existing schedule to control execution conditions, exclusions, and termination criteria",
        "requestBody": {
          "description": "Schedule rule configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddScheduleRuleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rule added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/add_solar_schedule/": {
      "post": {
        "description": "Create a solar event-based schedule that executes a webhook or workflow based on sunrise, sunset, or other solar events",
        "requestBody": {
          "description": "Solar schedule configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddSolarScheduleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schedule created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_single_schedule_details/": {
      "post": {
        "description": "Retrieve detailed information about a specific schedule by its UUID, including driver configuration, status, execution history, timezone conversions, and associated rules",
        "requestBody": {
          "description": "Schedule UUID",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSingleScheduleDetailsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSingleScheduleDetailsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or schedule not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/delete_schedule/": {
      "delete": {
        "description": "Delete a schedule by its UUID. This permanently removes the schedule and all associated rules",
        "requestBody": {
          "description": "Schedule UUID",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteScheduleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schedule deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteScheduleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or schedule not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/change_schedule_status/": {
      "post": {
        "description": "Update the status of an existing schedule. Use this endpoint to activate or pause a schedule without deleting it",
        "requestBody": {
          "description": "Schedule status update configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangeScheduleStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleStatusUpdateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or schedule not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_schedules_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of schedules filtered by status (active, inactive, paused, completed, or expired)",
        "parameters": [
          {
            "name": "filter_status",
            "in": "query",
            "required": true,
            "description": "Filter schedules by status",
            "schema": {
              "type": "string",
              "enum": [
                "active",
                "inactive",
                "paused",
                "completed",
                "expired"
              ]
            }
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "description": "Page number to retrieve (starts from 1)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "default": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSchedulesPaginatedResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/get_all_pending_approvals_paginated/": {
      "get": {
        "description": "Retrieve a paginated list of all pending approvals for workflows that are waiting for human approval",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "description": "Page number to retrieve (starts from 1)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "default": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetAllPendingApprovalsPaginatedResponse"
                }
              }
            }
          },
          "422": {
            "description": "Page out of range or project brand not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorWithMeta"
                }
              }
            }
          }
        }
      }
    },
    "/v1/api/human_approval_action/": {
      "post": {
        "description": "Approve or reject a pending workflow approval. Approving allows the workflow to continue, while rejecting skips the current step and moves to the failure path",
        "requestBody": {
          "description": "Human approval action configuration",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HumanApprovalActionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Action processed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HumanApprovalActionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request or execution plan not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Resource": {
        "required": [
          "id",
          "name"
        ],
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique identifier for the resource",
            "type": "string"
          },
          "name": {
            "description": "Name of the resource",
            "type": "string"
          },
          "type": {
            "description": "Type of the resource",
            "type": "string"
          },
          "created_at": {
            "description": "ISO 8601 timestamp when the resource was created",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "description": "ISO 8601 timestamp when the resource was last updated",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "CreateResource": {
            "required": [
          "name"
            ],
            "type": "object",
            "properties": {
          "name": {
            "description": "Name of the resource",
            "type": "string"
          },
          "type": {
            "description": "Type of the resource",
            "type": "string"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "limit": {
                "type": "integer",
            "description": "Number of items per page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of items to skip"
          },
          "total": {
            "type": "integer",
            "description": "Total number of items"
          },
          "has_more": {
            "type": "boolean",
            "description": "Whether there are more items available"
          }
        }
      },
      "WebhookEvent": {
        "required": [
          "event",
          "data"
        ],
        "type": "object",
        "properties": {
          "event": {
            "description": "Type of event",
            "type": "string",
            "enum": ["resource.created", "resource.updated", "resource.deleted"]
          },
          "data": {
            "description": "Event data payload",
            "type": "object"
          },
          "timestamp": {
            "description": "ISO 8601 timestamp of when the event occurred",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "Error": {
        "required": [
          "error",
          "message"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          }
        }
      },
      "AddDomainRequest": {
        "required": [
          "protocol_type",
          "domain",
          "rate_limit_enabled",
          "concurrency_control_enabled",
          "max_concurrent_jobs",
          "max_requests_per_second"
        ],
        "type": "object",
        "properties": {
          "protocol_type": {
            "type": "string",
            "description": "Protocol type for the domain (e.g., 'https', 'http')"
          },
          "domain": {
            "type": "string",
            "description": "Domain name to add"
          },
          "rate_limit_enabled": {
            "type": "boolean",
            "description": "Enable rate limiting for this domain"
          },
          "concurrency_control_enabled": {
            "type": "boolean",
            "description": "Enable concurrency control for this domain"
          },
          "max_concurrent_jobs": {
            "type": "integer",
            "description": "Maximum number of concurrent jobs allowed"
          },
          "max_requests_per_second": {
            "type": "integer",
            "description": "Maximum requests per second allowed"
          }
        }
      },
      "AddDomainResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message or error details"
          }
        }
      },
      "Domain": {
        "type": "object",
        "properties": {
          "protocol_type": {
            "type": "string",
            "description": "Protocol type for the domain"
          },
          "rate_limit_enabled": {
            "type": "boolean",
            "description": "Whether rate limiting is enabled"
          },
          "concurrency_control_enabled": {
            "type": "boolean",
            "description": "Whether concurrency control is enabled"
          },
          "max_concurrent_jobs": {
            "type": "integer",
            "description": "Maximum concurrent jobs allowed"
          },
          "max_requests_per_second": {
            "type": "integer",
            "description": "Maximum requests per second allowed"
          },
          "domain_uuid": {
            "type": "string",
            "description": "Unique identifier for the domain"
          },
          "domain_name": {
            "type": "string",
            "description": "Domain name"
          }
        }
      },
      "DomainPaginationMeta": {
        "type": "object",
        "properties": {
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "total_count": {
            "type": "integer",
            "description": "Total number of domains"
          },
          "per_page": {
            "type": "integer",
            "description": "Number of items per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages"
          },
          "has_next": {
            "type": "boolean",
            "description": "Whether there is a next page"
          },
          "has_prev": {
            "type": "boolean",
            "description": "Whether there is a previous page"
          }
        }
      },
      "GetDomainPaginatedResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Domain"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/DomainPaginationMeta"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "GetDomainUuidRequest": {
        "required": [
          "domain_name",
          "protocol_type"
        ],
        "type": "object",
        "properties": {
          "domain_name": {
            "type": "string",
            "description": "Domain name to look up"
          },
          "protocol_type": {
            "type": "string",
            "description": "Protocol type for the domain (e.g., 'https', 'http')"
          }
        }
      },
      "GetDomainUuidResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "domain_uuid": {
            "type": "string",
            "description": "Unique identifier for the domain"
          }
        }
      },
      "AddWebhookTemplateRequest": {
        "required": [
          "webhook_name",
          "webhook_description",
          "method",
          "path",
          "domain_uuid",
          "retry_delay",
          "retry_backoff_mode",
          "max_retries",
          "request_timeout_in_milliseconds",
          "request_body_json",
          "headers_json",
          "query_params_json"
        ],
        "type": "object",
        "properties": {
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook template"
          },
          "webhook_description": {
            "type": "string",
            "description": "Description of the webhook template"
          },
          "method": {
            "type": "string",
            "description": "HTTP method (e.g., 'GET', 'POST', 'PUT', 'DELETE')",
            "enum": ["GET", "POST", "PUT", "DELETE", "PATCH"]
          },
          "path": {
            "type": "string",
            "description": "URL path for the webhook (supports template variables)"
          },
          "domain_uuid": {
            "type": "string",
            "description": "UUID of the domain associated with this webhook template"
          },
          "retry_delay": {
            "type": "integer",
            "description": "Delay in seconds between retry attempts"
          },
          "retry_backoff_mode": {
            "type": "string",
            "description": "Retry backoff strategy",
            "enum": ["linear", "exponential"]
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retry attempts"
          },
          "request_timeout_in_milliseconds": {
            "type": "integer",
            "description": "Request timeout in milliseconds"
          },
          "request_body_json": {
            "type": "object",
            "description": "Request body as JSON object (supports template variables)"
          },
          "headers_json": {
            "type": "object",
            "description": "HTTP headers as JSON object (supports template variables)"
          },
          "query_params_json": {
            "type": "object",
            "description": "Query parameters as JSON object (supports template variables)"
          }
        }
      },
      "AddWebhookTemplateResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "webhook_template_id": {
            "type": "string",
            "description": "Unique identifier for the created webhook template"
          },
          "message": {
            "type": "string",
            "description": "Success message or error details"
          }
        }
      },
      "GetWebhookTemplatePaginatedResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WebhookTemplateListItem"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "WebhookTemplateListItem": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "URL path for the webhook template"
          },
          "method": {
            "type": "string",
            "description": "HTTP method (e.g., 'GET', 'POST', 'PUT', 'DELETE')"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the template was created (in your brand's selected timezone with offset)"
          },
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook template"
          },
          "webhook_description": {
            "type": "string",
            "description": "Description of the webhook template"
          },
          "request_timeout_in_milliseconds": {
            "type": "integer",
            "description": "Request timeout in milliseconds"
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retry attempts"
          },
          "retry_delay": {
            "type": "integer",
            "description": "Delay in seconds between retry attempts"
          },
          "retry_backoff_mode": {
            "type": "string",
            "description": "Retry backoff strategy",
            "enum": ["linear", "exponential"]
          },
          "domain_details": {
            "type": "object",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain name"
              },
              "protocol_type": {
                "type": "string",
                "description": "Protocol type (e.g., 'https', 'http')"
              }
            }
          },
          "webhook_uuid": {
            "type": "string",
            "description": "Unique identifier for the webhook template"
          }
        }
      },
      "GetWebhookTemplateUuidRequest": {
        "required": [
          "webhook_uuid"
        ],
        "type": "object",
        "properties": {
          "webhook_uuid": {
            "type": "string",
            "description": "UUID of the webhook template to retrieve"
          }
        }
      },
      "GetWebhookTemplateUuidResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "data": {
            "$ref": "#/components/schemas/WebhookTemplateDetails"
          }
        }
      },
      "WebhookTemplateDetails": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "URL path for the webhook template"
          },
          "method": {
            "type": "string",
            "description": "HTTP method (e.g., 'GET', 'POST', 'PUT', 'DELETE')"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for timestamps (matches your brand's selected timezone)"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the template was created (in your brand's selected timezone with offset)"
          },
          "webhook_uuid": {
            "type": "string",
            "description": "Unique identifier for the webhook template"
          },
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook template"
          },
          "webhook_description": {
            "type": "string",
            "description": "Description of the webhook template"
          },
          "request_timeout_in_milliseconds": {
            "type": "integer",
            "description": "Request timeout in milliseconds"
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retry attempts"
          },
          "retry_delay": {
            "type": "integer",
            "description": "Delay in seconds between retry attempts"
          },
          "retry_backoff_mode": {
            "type": "string",
            "description": "Retry backoff strategy",
            "enum": ["linear", "exponential"]
          },
          "domain_details": {
            "type": "object",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain name"
              },
              "protocol_type": {
                "type": "string",
                "description": "Protocol type (e.g., 'https', 'http')"
              }
            }
          },
          "expected_system_variables": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of system secret variable names expected in this template"
          },
          "headers_json": {
            "type": "object",
            "description": "HTTP headers as JSON object (supports template variables)"
          },
          "query_params_json": {
            "type": "object",
            "description": "Query parameters as JSON object (supports template variables)"
          },
          "request_body_json": {
            "type": "object",
            "description": "Request body as JSON object (supports template variables)"
          },
          "webhook_uuid": {
            "type": "string",
            "description": "Unique identifier for the webhook template"
          }
        }
      },
      "GetWebhookTemplateUuidByNameRequest": {
        "required": [
          "webhook_name"
        ],
        "type": "object",
        "properties": {
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook template"
          }
        }
      },
      "GetWebhookTemplateUuidByNameResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "webhook_uuid": {
            "type": "string",
            "description": "Unique identifier for the webhook template"
          }
        }
      },
      "GetWebhookTemplateUuidByNameErrorResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "error": {
            "type": "string",
            "description": "Error message"
          }
        }
      },
      "DeleteWebhookTemplateRequest": {
        "required": [
          "webhook_template_uuid"
        ],
        "type": "object",
        "properties": {
          "webhook_template_uuid": {
            "type": "string",
            "description": "UUID of the webhook template to delete"
          }
        }
      },
      "DeleteWebhookTemplateResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "message": {
            "type": "string",
            "description": "Success message confirming the deletion"
          }
        }
      },
      "AddSystemSecretRequest": {
        "required": [
          "secret_key",
          "secret_value"
        ],
        "type": "object",
        "properties": {
          "secret_key": {
            "type": "string",
            "description": "Unique identifier/key name for the secret"
          },
          "secret_value": {
            "type": "string",
            "description": "The secret value to store"
          }
        }
      },
      "AddSystemSecretResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "AddSystemSecretErrorResponse": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "secret_uuid": {
            "type": "string",
            "description": "UUID of the existing secret"
          }
        }
      },
      "GetSecretsPaginatedResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SecretListItem"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "SecretListItem": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The secret key name"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the secret was created (in your brand's selected timezone with offset)"
          },
          "call_key": {
            "type": "string",
            "description": "Template syntax to use this secret in webhooks (e.g., '{{ ##key }}')"
          },
          "secret_uuid": {
            "type": "string",
            "description": "Unique identifier for the secret"
          }
        }
      },
      "PaginationMeta": {
        "type": "object",
        "properties": {
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "total_count": {
            "type": "integer",
            "description": "Total number of secrets"
          },
          "per_page": {
            "type": "integer",
            "description": "Number of items per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages"
          },
          "has_next": {
            "type": "boolean",
            "description": "Whether there is a next page"
          },
          "has_prev": {
            "type": "boolean",
            "description": "Whether there is a previous page"
          }
        }
      },
      "UpdateSecretValueRequest": {
        "required": [
          "secret_uuid",
          "secret_updated_value"
        ],
        "type": "object",
        "properties": {
          "secret_uuid": {
            "type": "string",
            "description": "UUID of the secret to update"
          },
          "secret_updated_value": {
            "type": "string",
            "description": "New value for the secret"
          }
        }
      },
      "UpdateSecretValueResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "GetValueOfSecretRequest": {
        "required": [
          "secret_uuid"
        ],
        "type": "object",
        "properties": {
          "secret_uuid": {
            "type": "string",
            "description": "UUID of the secret to retrieve"
          }
        }
      },
      "GetValueOfSecretResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "data": {
            "$ref": "#/components/schemas/SecretDetails"
          }
        }
      },
      "SecretDetails": {
        "type": "object",
        "properties": {
          "secret_key": {
            "type": "string",
            "description": "The secret key name"
          },
          "secret_value": {
            "type": "string",
            "description": "The actual secret value"
          },
          "call_key": {
            "type": "string",
            "description": "Template syntax to use this secret in webhooks (e.g., '{{ #secret_key }}')"
          },
          "secret_uuid": {
            "type": "string",
            "description": "Unique identifier for the secret"
          }
        }
      },
      "DeleteSecretRequest": {
        "required": [
          "secret_uuid"
        ],
        "type": "object",
        "properties": {
          "secret_uuid": {
            "type": "string",
            "description": "UUID of the secret to delete"
          }
        }
      },
      "DeleteSecretResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "DeleteSecretErrorResponse": {
        "type": "object",
        "properties": {
          "secret_uuid": {
            "type": "string",
            "description": "UUID of the secret"
          }
        }
      },
      "AddWorkflowTemplateRequest": {
        "required": [
          "workflow_name",
          "workflow_description",
          "runtype"
        ],
        "type": "object",
        "properties": {
          "workflow_name": {
            "type": "string",
            "description": "Name of the workflow template"
          },
          "workflow_description": {
            "type": "string",
            "description": "Description of the workflow template"
          },
          "runtype": {
            "type": "string",
            "enum": [
              "fifo_sequential",
              "concurrently"
            ],
            "description": "Execution mode: 'fifo_sequential' for strict sequential order, 'concurrently' for parallel execution (note: in concurrent mode, only system variables are evaluated; initial.variable, response, and header variables are not available)"
          }
        }
      },
      "AddWorkflowTemplateResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "Unique identifier for the created workflow template"
          }
        }
      },
      "AddWorkflowTemplateErrorResponse": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful (false in error case)"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "UUID of the existing workflow with the same name"
          }
        }
      },
      "GetWorkflowTemplatePaginatedResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowTemplateListItem"
            },
            "description": "Array of workflow template objects"
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "WorkflowTemplateListItem": {
        "type": "object",
        "properties": {
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the workflow template was created (in your brand's selected timezone with offset)"
          },
          "workflow_name": {
            "type": "string",
            "description": "Name of the workflow template"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "Unique identifier for the workflow template"
          },
          "workflow_description": {
            "type": "string",
            "description": "Description of the workflow template"
          },
          "runtype": {
            "type": "string",
            "enum": [
              "fifo_sequential",
              "concurrently"
            ],
            "description": "Execution mode: 'fifo_sequential' for strict sequential order, 'concurrently' for parallel execution"
          },
          "total_workflow_steps": {
            "type": "integer",
            "description": "Total number of steps in the workflow"
          }
        }
      },
      "GetWorkflowTemplateUuidRequest": {
        "required": [
          "workflow_name"
        ],
        "type": "object",
        "properties": {
          "workflow_name": {
            "type": "string",
            "description": "Name of the workflow template"
          }
        }
      },
      "GetWorkflowTemplateUuidResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "Unique identifier for the workflow template"
          }
        }
      },
      "AddWorkflowStepRequest": {
        "required": [
          "index",
          "workflow_uuid",
          "webhook_name",
          "webhook_description",
          "method",
          "path",
          "domain_uuid",
          "human_approval_required",
          "step_identifier",
          "on_success_next_step_identifier",
          "on_fail_next_step_identifier",
          "delay_to_next_step",
          "retry_delay",
          "retry_backoff_mode",
          "max_retries",
          "request_timeout_in_milliseconds",
          "request_body_json",
          "headers_json",
          "query_params_json"
        ],
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "description": "Priority index for FIFO execution order (0 is first)"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "UUID of the workflow template to add the step to"
          },
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook step"
          },
          "webhook_description": {
            "type": "string",
            "description": "Description of the webhook step"
          },
          "method": {
            "type": "string",
            "enum": ["GET", "POST", "PUT", "DELETE", "PATCH"],
            "description": "HTTP method for the webhook call"
          },
          "path": {
            "type": "string",
            "description": "URL path for the webhook (supports template variables)"
          },
          "domain_uuid": {
            "type": "string",
            "description": "UUID of the domain associated with this webhook step"
          },
          "human_approval_required": {
            "type": "boolean",
            "description": "Whether this step requires human approval before execution"
          },
          "step_identifier": {
            "type": "string",
            "description": "Unique identifier (slug) for this step"
          },
          "on_success_next_step_identifier": {
            "type": "string",
            "description": "Step identifier to execute next on success"
          },
          "on_fail_next_step_identifier": {
            "type": "string",
            "description": "Step identifier to execute next on failure"
          },
          "delay_to_next_step": {
            "type": "integer",
            "description": "Delay in seconds before executing the next step"
          },
          "execution_condition": {
            "type": "object",
            "description": "Condition that must be met for this step to execute",
            "properties": {
              "operator": {
                "type": "string",
                "enum": ["eq", "ne", "lt", "gt", "lte", "gte", "in", "contains"],
                "description": "Comparison operator"
              },
              "field": {
                "type": "string",
                "description": "Field path to evaluate"
              },
              "value": {
                "type": "string",
                "description": "Value to compare against"
              }
            }
          },
          "retry_delay": {
            "type": "integer",
            "description": "Delay in seconds between retry attempts (default: 10)"
          },
          "retry_backoff_mode": {
            "type": "string",
            "enum": ["linear", "exponential"],
            "description": "Retry backoff strategy (default: linear)"
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retry attempts (default: 5)"
          },
          "request_timeout_in_milliseconds": {
            "type": "integer",
            "description": "Request timeout in milliseconds (default: 5000)"
          },
          "request_body_json": {
            "type": "object",
            "description": "Request body as JSON object (supports template variables: {{ #key }}, {{ step.response.key }}, {{ initial.key }})"
          },
          "headers_json": {
            "type": "object",
            "description": "HTTP headers as JSON object (supports template variables)"
          },
          "query_params_json": {
            "type": "object",
            "description": "Query parameters as JSON object (supports template variables)"
          }
        }
      },
      "AddWorkflowStepResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "GetWorkflowTemplateDetailRequest": {
        "required": [
          "workflow_uuid"
        ],
        "type": "object",
        "properties": {
          "workflow_uuid": {
            "type": "string",
            "description": "UUID of the workflow template"
          }
        }
      },
      "GetWorkflowTemplateDetailResponse": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/WorkflowTemplateDetail"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          }
        }
      },
      "WorkflowTemplateDetail": {
        "type": "object",
        "properties": {
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for timestamps (matches your brand's selected timezone)"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the workflow template was created (in your brand's selected timezone with offset)"
          },
          "workflow_name": {
            "type": "string",
            "description": "Name of the workflow template"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "Unique identifier for the workflow template"
          },
          "workflow_description": {
            "type": "string",
            "description": "Description of the workflow template"
          },
          "runtype": {
            "type": "string",
            "enum": [
              "fifo_sequential",
              "concurrently"
            ],
            "description": "Execution mode: 'fifo_sequential' for strict sequential order, 'concurrently' for parallel execution"
          },
          "workflow_steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowStepDetail"
            },
            "description": "Array of workflow steps"
          }
        }
      },
      "WorkflowStepDetail": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "description": "Priority index for FIFO execution order"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for timestamps (matches your brand's selected timezone)"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the workflow step was created (in your brand's selected timezone with offset)"
          },
          "step_identifier": {
            "type": "string",
            "description": "Unique identifier (slug) for this step"
          },
          "human_approval_required": {
            "type": "boolean",
            "description": "Whether this step requires human approval"
          },
          "delay_to_next_step": {
            "type": "integer",
            "description": "Delay in seconds before executing the next step"
          },
          "webhook": {
            "$ref": "#/components/schemas/WorkflowStepWebhook"
          },
          "step_uuid": {
            "type": "string",
            "description": "Unique identifier for the workflow step"
          },
          "execution_conditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExecutionCondition"
            },
            "description": "Array of execution conditions for this step"
          }
        }
      },
      "ExecutionCondition": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "Value to compare against"
          },
          "operator": {
            "type": "string",
            "enum": [
              "eq",
              "ne",
              "lt",
              "gt",
              "lte",
              "gte",
              "in",
              "contains"
            ],
            "description": "Comparison operator"
          },
          "field": {
            "type": "string",
            "description": "Field path to evaluate"
          }
        }
      },
      "WorkflowStepWebhook": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "URL path for the webhook"
          },
          "domain": {
            "$ref": "#/components/schemas/WorkflowStepDomain"
          },
          "method": {
            "type": "string",
            "enum": [
              "GET",
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "description": "HTTP method"
          },
          "webhook_name": {
            "type": "string",
            "description": "Name of the webhook"
          },
          "expected_system_variables": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of system variables expected in this webhook"
          },
          "headers_json": {
            "type": "object",
            "description": "HTTP headers as JSON object"
          },
          "query_params_json": {
            "type": "object",
            "description": "Query parameters as JSON object"
          },
          "request_body_json": {
            "type": "object",
            "description": "Request body as JSON object"
          },
          "webhook_uuid": {
            "type": "string",
            "description": "Unique identifier for the webhook"
          }
        }
      },
      "WorkflowStepDomain": {
        "type": "object",
        "properties": {
          "protocol": {
            "type": "string",
            "enum": [
              "http",
              "https"
            ],
            "description": "Protocol type"
          },
          "domain": {
            "type": "string",
            "description": "Domain name"
          }
        }
      },
      "TimezoneOptionsResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimezoneOption"
            },
            "description": "Array of timezone options"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          }
        }
      },
      "TimezoneOption": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "description": "Human-readable timezone label"
          },
          "value": {
            "type": "string",
            "description": "IANA timezone identifier"
          }
        }
      },
      "AddIntervalScheduleRequest": {
        "required": [
          "interval_value",
          "interval_period",
          "schedule_to",
          "model_to_schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "interval_value": {
            "type": "integer",
            "description": "Number of time units between executions (must be > 0)",
            "minimum": 1
          },
          "interval_period": {
            "type": "string",
            "enum": [
              "second",
              "minute",
              "hour"
            ],
            "description": "Unit of time: 'second', 'minute', or 'hour'"
          },
          "schedule_to": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Target type: 'webhook' or 'workflow'"
          },
          "model_to_schedule_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template to schedule"
          },
          "initial_context_template": {
            "type": "object",
            "description": "Key-value pairs passed as {{ initial.key }} variables to the webhook/workflow",
            "additionalProperties": true
          }
        }
      },
      "AddCronScheduleRequest": {
        "required": [
          "cron_expression",
          "cron_timezone",
          "schedule_to",
          "model_to_schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "cron_expression": {
            "type": "string",
            "description": "Standard cron expression (e.g., '0 0 * * *' for daily at midnight)"
          },
          "cron_timezone": {
            "type": "string",
            "description": "IANA timezone identifier"
          },
          "schedule_to": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Target type: 'webhook' or 'workflow'"
          },
          "model_to_schedule_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template to schedule"
          },
          "initial_context_template": {
            "type": "object",
            "description": "Key-value pairs passed as {{ initial.key }} variables to the webhook/workflow",
            "additionalProperties": true
          }
        }
      },
      "AddClockedScheduleRequest": {
        "required": [
          "clocked_run_at",
          "clocked_timezone",
          "is_one_off_task",
          "schedule_to",
          "model_to_schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "clocked_run_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 datetime string for when to execute"
          },
          "clocked_timezone": {
            "type": "string",
            "description": "IANA timezone identifier"
          },
          "is_one_off_task": {
            "type": "boolean",
            "description": "Whether this is a one-time task"
          },
          "schedule_to": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Target type: 'webhook' or 'workflow'"
          },
          "model_to_schedule_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template to schedule"
          },
          "initial_context_template": {
            "type": "object",
            "description": "Key-value pairs passed as {{ initial.key }} variables to the webhook/workflow",
            "additionalProperties": true
          }
        }
      },
      "AddScheduleRuleRequest": {
        "required": [
          "schedule_uuid",
          "rule_type"
        ],
        "type": "object",
        "properties": {
          "schedule_uuid": {
            "type": "string",
            "description": "UUID of the schedule to add the rule to"
          },
          "rule_type": {
            "type": "string",
            "enum": [
              "time_window",
              "calendar_window",
              "solar_window",
              "exclusion",
              "termination"
            ],
            "description": "Type of rule"
          },
          "start_time": {
            "type": "string",
            "format": "time",
            "description": "Start time for time window rules (format: HH:mm:ss)"
          },
          "end_time": {
            "type": "string",
            "format": "time",
            "description": "End time for time window rules (format: HH:mm:ss)"
          },
          "timezone": {
            "type": "string",
            "description": "Timezone for time window rules (IANA timezone identifier)"
          },
          "allow_days": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1,
              "maximum": 31
            },
            "description": "Array of day numbers (1-31) for calendar window rules"
          },
          "allow_months": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1,
              "maximum": 12
            },
            "description": "Array of month numbers (1-12) for calendar window rules"
          },
          "exclusion_dates": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "date"
            },
            "description": "Array of dates to exclude (format: YYYY-MM-DD) for exclusion rules"
          },
          "solar_start_event": {
            "type": "string",
            "enum": [
              "sunrise",
              "sunset",
              "civil_dawn",
              "civil_dusk",
              "nautical_dawn",
              "nautical_dusk",
              "astronomical_dawn",
              "astronomical_dusk"
            ],
            "description": "Solar event for start of solar window"
          },
          "solar_end_event": {
            "type": "string",
            "enum": [
              "sunrise",
              "sunset",
              "civil_dawn",
              "civil_dusk",
              "nautical_dawn",
              "nautical_dusk",
              "astronomical_dawn",
              "astronomical_dusk"
            ],
            "description": "Solar event for end of solar window"
          },
          "solar_lat": {
            "type": "string",
            "description": "Latitude for solar window rules (decimal degrees)"
          },
          "solar_long": {
            "type": "string",
            "description": "Longitude for solar window rules (decimal degrees)"
          },
          "max_run_to_terminate_after": {
            "type": "integer",
            "description": "Maximum number of runs before termination (for termination rules)"
          },
          "expire_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 datetime when schedule should expire (for termination rules)"
          }
        }
      },
      "AddSolarScheduleRequest": {
        "required": [
          "solar_event",
          "solar_lat",
          "solar_long",
          "schedule_to",
          "model_to_schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "solar_event": {
            "type": "string",
            "enum": [
              "sunrise",
              "sunset",
              "civil_dawn",
              "civil_dusk",
              "nautical_dawn",
              "nautical_dusk",
              "astronomical_dawn",
              "astronomical_dusk"
            ],
            "description": "Solar event type"
          },
          "solar_lat": {
            "type": "string",
            "description": "Latitude in decimal degrees"
          },
          "solar_long": {
            "type": "string",
            "description": "Longitude in decimal degrees"
          },
          "solar_offset_seconds": {
            "type": "integer",
            "description": "Offset in seconds to adjust timing (e.g., 5 for 5 seconds after, -300 for 5 minutes before)"
          },
          "schedule_to": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Target type: 'webhook' or 'workflow'"
          },
          "model_to_schedule_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template to schedule"
          },
          "initial_context_template": {
            "type": "object",
            "description": "Key-value pairs passed as {{ initial.key }} variables to the webhook/workflow",
            "additionalProperties": true
          }
        }
      },
      "ScheduleResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the schedule was created successfully"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "GetSchedulesPaginatedResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleListItem"
            },
            "description": "Array of schedule objects"
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "ScheduleListItem": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for the schedule status"
          },
          "status": {
            "type": "string",
            "enum": [
              "active",
              "inactive",
              "paused",
              "completed",
              "expired"
            ],
            "description": "Current status of the schedule"
          },
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Type of schedule target"
          },
          "model_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template being scheduled"
          },
          "driver_type": {
            "type": "string",
            "enum": [
              "interval",
              "cron",
              "clocked",
              "solar",
              "debounce"
            ],
            "description": "Schedule driver type"
          },
          "last_run_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 timestamp of the last execution (UTC)"
          },
          "next_run_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 timestamp of the next scheduled execution (UTC)"
          },
          "total_schedule_triggered": {
            "type": "integer",
            "description": "Total number of times the schedule has been triggered"
          },
          "locale_timezone_converted_details": {
            "$ref": "#/components/schemas/LocaleTimezoneConvertedDetails"
          },
          "schedule_uuid": {
            "type": "string",
            "description": "Unique identifier for the schedule"
          }
        }
      },
      "LocaleTimezoneConvertedDetails": {
        "type": "object",
        "properties": {
          "preferred_timezone": {
            "type": "string",
            "description": "IANA timezone identifier used for conversion"
          },
          "time_left_to_trigger": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable time until next execution"
          },
          "last_run_at_by_preferred_timezone": {
            "type": "string",
            "nullable": true,
            "description": "Last run time converted to preferred timezone (ISO 8601 with offset)"
          },
          "next_run_at_by_preferred_timezone": {
            "type": "string",
            "nullable": true,
            "description": "Next run time converted to preferred timezone (ISO 8601 with offset)"
          }
        }
      },
      "GetSingleScheduleDetailsRequest": {
        "required": [
          "schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "schedule_uuid": {
            "type": "string",
            "description": "UUID of the schedule to retrieve details for"
          }
        }
      },
      "GetSingleScheduleDetailsResponse": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/ScheduleDetails"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          }
        }
      },
      "ScheduleDetails": {
        "type": "object",
        "properties": {
          "driver": {
            "$ref": "#/components/schemas/ScheduleDriver"
          },
          "status": {
            "type": "string",
            "enum": [
              "active",
              "inactive",
              "paused",
              "completed",
              "expired"
            ],
            "description": "Current status of the schedule"
          },
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "workflow"
            ],
            "description": "Type of schedule target"
          },
          "last_run_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 timestamp of the last execution (UTC)"
          },
          "next_run_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 timestamp of the next scheduled execution (UTC)"
          },
          "locale_timezone_converted_details": {
            "$ref": "#/components/schemas/LocaleTimezoneConvertedDetails"
          },
          "schedule_uuid": {
            "type": "string",
            "description": "Unique identifier for the schedule"
          },
          "schedule_applied_model_uuid": {
            "type": "string",
            "description": "UUID of the webhook or workflow template being scheduled"
          },
          "target_name": {
            "type": "string",
            "description": "Name of the webhook or workflow template"
          },
          "target_description": {
            "type": "string",
            "description": "Description of the webhook or workflow template"
          },
          "total_triggered": {
            "type": "integer",
            "description": "Total number of times the schedule has been triggered"
          },
          "rules": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Rule object (structure varies by rule type)"
            },
            "description": "Array of rules associated with this schedule"
          }
        }
      },
      "ScheduleDriver": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "interval",
              "cron",
              "clocked",
              "solar",
              "debounce"
            ],
            "description": "Driver type"
          },
          "interval_value": {
            "type": "integer",
            "nullable": true,
            "description": "Number of time units between executions (for interval schedules)"
          },
          "interval_period": {
            "type": "string",
            "enum": [
              "second",
              "minute",
              "hour"
            ],
            "nullable": true,
            "description": "Unit of time for interval schedules"
          },
          "cron_expression": {
            "type": "string",
            "nullable": true,
            "description": "Cron expression (for cron schedules)"
          },
          "cron_timezone": {
            "type": "string",
            "nullable": true,
            "description": "IANA timezone identifier (for cron schedules)"
          },
          "clocked_run_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO 8601 datetime for execution (for clocked schedules)"
          },
          "clocked_timezone": {
            "type": "string",
            "nullable": true,
            "description": "IANA timezone identifier (for clocked schedules)"
          },
          "solar_event": {
            "type": "string",
            "enum": [
              "sunrise",
              "sunset",
              "civil_dawn",
              "civil_dusk",
              "nautical_dawn",
              "nautical_dusk",
              "astronomical_dawn",
              "astronomical_dusk"
            ],
            "nullable": true,
            "description": "Solar event type (for solar schedules)"
          },
          "solar_lat": {
            "type": "string",
            "nullable": true,
            "description": "Latitude in decimal degrees (for solar schedules)"
          },
          "solar_long": {
            "type": "string",
            "nullable": true,
            "description": "Longitude in decimal degrees (for solar schedules)"
          },
          "is_one_off": {
            "type": "boolean",
            "description": "Whether this is a one-time task"
          },
          "solar_offset": {
            "type": "integer",
            "nullable": true,
            "description": "Offset in seconds (for solar schedules)"
          }
        }
      },
      "DeleteScheduleRequest": {
        "required": [
          "schedule_uuid"
        ],
        "type": "object",
        "properties": {
          "schedule_uuid": {
            "type": "string",
            "description": "UUID of the schedule to delete"
          }
        }
      },
      "DeleteScheduleResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the schedule was deleted successfully"
          },
          "error": {
            "type": "string",
            "description": "Success message indicating the schedule was deleted"
          }
        }
      },
      "ChangeScheduleStatusRequest": {
        "required": [
          "schedule_uuid",
          "update_status_to"
        ],
        "type": "object",
        "properties": {
          "schedule_uuid": {
            "type": "string",
            "description": "UUID of the schedule to update"
          },
          "update_status_to": {
            "type": "string",
            "enum": [
              "active",
              "paused"
            ],
            "description": "New status: 'active' or 'paused'"
          }
        }
      },
      "ScheduleStatusUpdateResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the status was updated successfully"
          },
          "details": {
            "type": "string",
            "description": "Success message"
          }
        }
      },
      "GetAllPendingApprovalsPaginatedResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingApprovalItem"
            },
            "description": "Array of pending approval objects"
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          }
        }
      },
      "PendingApprovalItem": {
        "type": "object",
        "properties": {
          "execution_plan_uuid": {
            "type": "string",
            "description": "Unique identifier (UUID) for the execution plan"
          },
          "workflow_uuid": {
            "type": "string",
            "description": "UUID of the workflow template being executed"
          },
          "workflow_name": {
            "type": "string",
            "description": "Name of the workflow template"
          },
          "step_identifier": {
            "type": "string",
            "description": "Identifier of the current workflow step waiting for approval"
          },
          "workflow_index": {
            "type": "integer",
            "description": "Index/position of the workflow step"
          },
          "status": {
            "type": "string",
            "enum": [
              "waiting_approval"
            ],
            "description": "Execution status (always 'waiting_approval' for pending approvals)"
          },
          "human_approval_required": {
            "type": "boolean",
            "description": "Whether human approval is required for this step"
          },
          "delay_to_next_step": {
            "type": "integer",
            "description": "Delay in seconds before proceeding to the next step after approval"
          },
          "inserted_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the execution plan was created (in your brand's selected timezone with offset)"
          }
        }
      },
      "ErrorWithMeta": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the request was successful"
          },
          "timezone": {
            "type": "string",
            "description": "IANA timezone identifier indicating the timezone used for all timestamps in the response (matches your brand's selected timezone)"
          },
          "error": {
            "type": "string",
            "description": "Error message"
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        }
      },
      "HumanApprovalActionRequest": {
        "required": [
          "action",
          "execution_plan_uuid"
        ],
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "enum": [
              "approve",
              "reject"
            ],
            "description": "Action to take: 'approve' or 'reject'"
          },
          "execution_plan_uuid": {
            "type": "string",
            "description": "UUID of the execution plan waiting for approval"
          }
        }
      },
      "HumanApprovalActionResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Indicates if the action was processed successfully"
          },
          "message": {
            "type": "string",
            "description": "Success message indicating the action taken"
          }
        }
      }
    },
    "securitySchemes": {
      "apiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "x-hookpulse-api-key",
        "description": "API key for authentication. Get this from your dashboard by selecting a brand and going to API Keys section."
      },
      "brandUuidAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "x-brand-uuid",
        "description": "Brand UUID for authentication. Get this from your dashboard after adding a brand - it will be displayed in the UI."
      }
    }
  }
}